<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- PWA / App è¨­å®š -->
    <title>é›²ç«¯å¸³æœ¬</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="é›²ç«¯å¸³æœ¬">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#F8FAFC">

    <!-- è‡ªå‹•ç”¢ç”Ÿ App åœ–ç¤ºçš„è…³æœ¬ -->
    <script>
        (function() {
            try {
                var canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                var ctx = canvas.getContext('2d');
                
                // èƒŒæ™¯ (Slate-600 #475569)
                ctx.fillStyle = '#475569'; 
                ctx.fillRect(0, 0, 512, 512);
                
                // è£é£¾åœ“åœˆ
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 40;
                ctx.beginPath();
                ctx.arc(512, 512, 200, 0, Math.PI * 2);
                ctx.stroke();
                
                // æ–‡å­— "å¸³"
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 300px "Noto Sans TC", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // å¾®èª¿æ–‡å­—ä½ç½®ï¼Œä½¿å…¶å‚ç›´å±…ä¸­
                ctx.fillText('å¸³', 256, 270);

                var iconUrl = canvas.toDataURL('image/png');

                // è¨­å®š iOS åœ–ç¤º
                var linkApple = document.createElement('link');
                linkApple.rel = 'apple-touch-icon';
                linkApple.href = iconUrl;
                document.head.appendChild(linkApple);

                // è¨­å®šç€è¦½å™¨åˆ†é åœ–ç¤º
                var linkFavicon = document.createElement('link');
                linkFavicon.rel = 'icon';
                linkFavicon.type = 'image/png';
                linkFavicon.href = iconUrl;
                document.head.appendChild(linkFavicon);
            } catch (e) {
                console.error("Icon generation failed", e);
            }
        })();
    </script>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- å¼•å…¥ Lucide åœ–ç¤ºåº« -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&family=Noto+Sans+TC:wght@400;500;700;900&display=swap');
        body { 
            font-family: 'Inter', 'Noto Sans TC', sans-serif; 
            -webkit-tap-highlight-color: transparent; 
            /* é¿å… iOS ä¸‹æ‹‰å›å½ˆéœ²å‡ºç™½è‰²èƒŒæ™¯ */
            overscroll-behavior-y: none;
        }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .animate-in { animation: fadeIn 0.3s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .tabular-nums { font-variant-numeric: tabular-nums; }
        
        /* PWA å®‰å…¨å€åŸŸè¨­å®š (é¿é–‹ç€æµ·èˆ‡ Home Bar) */
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
        .pt-safe { padding-top: env(safe-area-inset-top); }
    </style>
</head>
<body class="bg-[#F8FAFC] text-slate-800 text-base selection:bg-slate-200">
    <div id="root"></div>

    <!-- Firebase SDK (æ¨¡çµ„åŒ–è¼‰å…¥) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
        import { getFirestore, collection, doc, onSnapshot, addDoc, deleteDoc, updateDoc, setDoc, query, where, writeBatch, getDoc } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-auth.js";
        
        // å°‡ SDK å‡½å¼æ›è¼‰åˆ° windowï¼Œä¾› React çµ„ä»¶ä½¿ç”¨
        window.FirebaseSDK = { 
            initializeApp, getFirestore, collection, doc, onSnapshot, addDoc, deleteDoc, 
            updateDoc, setDoc, query, where, writeBatch, getDoc, getAuth, 
            signInAnonymously, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut 
        };
        window.isFirebaseSDKReady = true;
    </script>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        const Icon = ({ name, size = 20, className = "" }) => {
            const ref = useRef(null);
            useEffect(() => {
                if (!window.lucide || !ref.current) return;
                const i = document.createElement('i');
                i.setAttribute('data-lucide', name);
                ref.current.innerHTML = '';
                ref.current.appendChild(i);
                window.lucide.createIcons({ root: ref.current, attrs: { width: String(size), height: String(size), class: className } });
            }, [name, size, className]);
            return <span ref={ref} style={{ display: 'inline-flex', verticalAlign: 'middle' }}></span>;
        };

        const firebaseConfig = JSON.parse(window.__firebase_config || '{}');

        // Helper: Local Date Strings
        const getLocalToday = () => {
            const d = new Date();
            return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
        };
        const getLocalMonth = () => {
            const d = new Date();
            return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
        };

        // Helper: Add Months to date (Correctly handles year rollover)
        const addMonthsToDate = (dateStr, months) => {
            const [y, m, d] = dateStr.split('-').map(Number);
            const newDate = new Date(y, m - 1 + months, 1);
            const maxDays = new Date(newDate.getFullYear(), newDate.getMonth() + 1, 0).getDate();
            const targetDay = Math.min(d, maxDays);
            if (months > 0) return `${newDate.getFullYear()}-${String(newDate.getMonth() + 1).padStart(2, '0')}-01`;
            return `${newDate.getFullYear()}-${String(newDate.getMonth() + 1).padStart(2, '0')}-${String(targetDay).padStart(2, '0')}`;
        };

        const DEFAULT_CATEGORIES = {
            expense: [
                { name: 'é£²é£Ÿ', icon: 'utensils', subs: ['æ—©é¤', 'åˆé¤', 'æ™šé¤', 'é£²æ–™', 'é›¶é£Ÿ'] },
                { name: 'äº¤é€š', icon: 'bus', subs: ['å…¬è»Š', 'æ·é‹', 'è¨ˆç¨‹è»Š', 'åŠ æ²¹', 'åœè»Š'] },
                { name: 'è³¼ç‰©', icon: 'shopping-bag', subs: ['æ—¥ç”¨å“', 'æœé£¾', '3C', 'ä¿é¤Š'] },
                { name: 'å¨›æ¨‚', icon: 'film', subs: ['é›»å½±', 'éŠæˆ²', 'èšæœƒ', 'è¨‚é–±'] },
                { name: 'å±…ä½', icon: 'home', subs: ['æˆ¿ç§Ÿ', 'æ°´é›»', 'ç“¦æ–¯', 'ç¶²è·¯'] },
                { name: 'é†«ç™‚', icon: 'stethoscope', subs: ['çœ‹è¨º', 'è—¥å“', 'ä¿å¥'] },
                { name: 'æ•™è‚²', icon: 'graduation-cap', subs: ['æ›¸ç±', 'èª²ç¨‹'] },
                { name: 'é‹å‹•', icon: 'dumbbell', subs: ['å¥èº«æˆ¿', 'è£å‚™', 'ç‘œçˆ'] }, 
                { name: 'å…¶ä»–', icon: 'more-horizontal', subs: [] }
            ],
            income: [
                { name: 'è–ªè³‡', icon: 'wallet', subs: ['æœ¬è–ª', 'å…¼è·'] },
                { name: 'çé‡‘', icon: 'gift', subs: ['å¹´çµ‚', 'åˆ†ç´…'] },
                { name: 'æŠ•è³‡', icon: 'trending-up', subs: ['è‚¡æ¯', 'åƒ¹å·®'] },
                { name: 'é›¶ç”¨éŒ¢', icon: 'coins', subs: [] },
                { name: 'å…¶ä»–', icon: 'more-horizontal', subs: [] }
            ]
        };

        const AVAILABLE_ICONS = ['utensils', 'coffee', 'beer', 'shopping-cart', 'shopping-bag', 'gift', 'bus', 'car', 'plane', 'bed', 'map', 'home', 'zap', 'wifi', 'phone', 'hammer', 'film', 'gamepad-2', 'music', 'camera', 'ticket', 'stethoscope', 'pill', 'heart', 'graduation-cap', 'book', 'briefcase', 'smile', 'frown', 'star', 'tag', 'dumbbell', 'more-horizontal'];

        const ACCOUNT_TYPES = {
            'cash': { label: 'ç¾é‡‘', iconName: 'coins', color: 'text-emerald-600 bg-emerald-50' },
            'bank': { label: 'éŠ€è¡Œ', iconName: 'landmark', color: 'text-blue-600 bg-blue-50' },
            'credit': { label: 'ä¿¡ç”¨å¡', iconName: 'credit-card', color: 'text-purple-600 bg-purple-50' },
            'electronic': { label: 'é›»å­è²¨å¹£', iconName: 'smartphone-nfc', color: 'text-sky-600 bg-sky-50' },
            'invest': { label: 'æŠ•è³‡ç†è²¡', iconName: 'trending-up', color: 'text-rose-600 bg-rose-50' },
            'payable': { label: 'æ‡‰ä»˜å¸³æ¬¾', iconName: 'file-minus', color: 'text-orange-600 bg-orange-50' },
            'receivable': { label: 'æ‡‰æ”¶å¸³æ¬¾', iconName: 'file-plus', color: 'text-teal-600 bg-teal-50' },
            'other': { label: 'å…¶å®ƒ', iconName: 'wallet', color: 'text-slate-600 bg-slate-100' }
        };

        const CATEGORY_COLORS = { 'é£²é£Ÿ': '#f59e0b', 'äº¤é€š': '#3b82f6', 'è³¼ç‰©': '#ec4899', 'å¨›æ¨‚': '#a855f7', 'å±…ä½': '#6366f1', 'é†«ç™‚': '#ef4444', 'æ•™è‚²': '#22c55e', 'è–ªè³‡': '#10b981', 'çé‡‘': '#eab308', 'æŠ•è³‡': '#14b8a6', 'è½‰å¸³': '#64748b', 'ä»£å¢Š': '#8b5cf6', 'é‚„æ¬¾': '#10b981', 'è‡ªå‹•ç¹³æ¬¾': '#94a3b8', 'é‹å‹•': '#f97316' };

        const CURRENCIES = ['TWD', 'USD', 'JPY', 'EUR', 'CNY', 'HKD', 'KRW', 'AUD', 'CAD', 'GBP', 'SGD', 'CHF'];
        
        const DEFAULT_RATES = {
            'TWD': 1, 'USD': 32.5, 'JPY': 0.22, 'EUR': 35.0, 'CNY': 4.5, 'HKD': 4.1, 
            'KRW': 0.024, 'AUD': 21.5, 'CAD': 24.0, 'GBP': 41.0, 'SGD': 24.2, 'CHF': 36.5
        };

        const MILESTONES = [
            { amount: 100000, title: 'ç¬¬ä¸€æ¡¶é‡‘', icon: 'sprout', color: 'text-emerald-600', bg: 'bg-emerald-50' },
            { amount: 500000, title: 'ç©å°‘æˆå¤š', icon: 'coins', color: 'text-teal-600', bg: 'bg-teal-50' },
            { amount: 1000000, title: 'ç™¾è¬å¯Œç¿', icon: 'gem', color: 'text-sky-600', bg: 'bg-sky-50' },
            { amount: 3000000, title: 'è³‡ç”¢å°æˆ', icon: 'award', color: 'text-indigo-600', bg: 'bg-indigo-50' },
            { amount: 5000000, title: 'åŠå€‹åƒè¬', icon: 'trophy', color: 'text-purple-600', bg: 'bg-purple-50' },
            { amount: 10000000, title: 'åƒè¬å¯Œè±ª', icon: 'crown', color: 'text-amber-600', bg: 'bg-amber-50' },
        ];

        function App() {
            const [sdkReady, setSdkReady] = useState(false);
            const [needConfig, setNeedConfig] = useState(false);
            const [configInput, setConfigInput] = useState('');
            const [user, setUser] = useState(null);
            const [loading, setLoading] = useState(true);
            const [activeTab, setActiveTab] = useState('home');
            const [error, setError] = useState(null);
            
            // View States
            const [currentLedgerMonth, setCurrentLedgerMonth] = useState(getLocalMonth());
            const [analysisMode, setAnalysisMode] = useState('month'); 
            const [analysisType, setAnalysisType] = useState('expense');
            const [analysisGroupBy, setAnalysisGroupBy] = useState('main'); 
            const [analysisDate, setAnalysisDate] = useState(getLocalMonth()); 
            const [analysisYear, setAnalysisYear] = useState(String(new Date().getFullYear()));
            const todayStr = getLocalToday();
            const firstDayStr = todayStr.slice(0, 8) + '01';
            const [analysisRange, setAnalysisRange] = useState({ start: firstDayStr, end: todayStr });
            const [selectedCategory, setSelectedCategory] = useState(null); 

            const fbRef = useRef(null);
            const authRef = useRef(null);
            const dbRef = useRef(null);
            const appId = 'my-cloud-ledger-pro';

            // Data States
            const [transactions, setTransactions] = useState([]);
            const [accounts, setAccounts] = useState([]);
            const [categories, setCategories] = useState(DEFAULT_CATEGORIES);
            const [recurring, setRecurring] = useState([]);
            const [retirement, setRetirement] = useState({ currentAge: 30, retireAge: 60, monthlyExpense: 30000, inflation: 2 });
            const [exchangeRates, setExchangeRates] = useState(DEFAULT_RATES);
            const [monthlyBudget, setMonthlyBudget] = useState(30000);
            
            const [currentBook, setCurrentBook] = useState({ id: 'main', name: 'æ—¥å¸¸å¸³æœ¬', currency: 'TWD' }); 
            const [books, setBooks] = useState([]);

            // Modal States
            const [isTxModalOpen, setIsTxModalOpen] = useState(false);
            const [isAccModalOpen, setIsAccModalOpen] = useState(false);
            const [isRecModalOpen, setIsRecModalOpen] = useState(false);
            const [isSettleModalOpen, setIsSettleModalOpen] = useState(false);
            const [isRetireModalOpen, setIsRetireModalOpen] = useState(false);
            const [isAddCatModalOpen, setIsAddCatModalOpen] = useState(false); 
            const [isEditCatModalOpen, setIsEditCatModalOpen] = useState(false); 
            const [isRateModalOpen, setIsRateModalOpen] = useState(false);
            const [isMarketValueModalOpen, setIsMarketValueModalOpen] = useState(false);
            const [isBookModalOpen, setIsBookModalOpen] = useState(false);
            const [isBookSelectOpen, setIsBookSelectOpen] = useState(false);

            // Form States
            const [targetMarketAccount, setTargetMarketAccount] = useState(null);
            const [newMarketValue, setNewMarketValue] = useState('');
            const [settleTargetTx, setSettleTargetTx] = useState(null);
            const [settleToAccount, setSettleToAccount] = useState('');
            const [editingCategoryType, setEditingCategoryType] = useState('expense');
            const [newCategoryName, setNewCategoryName] = useState('');
            const [newCatForm, setNewCatForm] = useState({ name: '', icon: 'tag', type: 'expense', subs: [] });
            const [editingCategory, setEditingCategory] = useState(null); 
            const [txForm, setTxForm] = useState({ type: 'expense', amount: '', toAmount: '', category: '', subCategory: '', accountId: '', toAccountId: '', debtor: '', date: getLocalToday(), note: '', currency: 'TWD', exchangeRate: 1 });
            const [isAdvanceSplit, setIsAdvanceSplit] = useState(false);
            const [splitData, setSplitData] = useState({ advances: [{ debtor: '', amount: '' }], principalAmount: '', sourceAccountId: '' });
            const [installment, setInstallment] = useState({ enabled: false, periods: 3 });
            const [accForm, setAccForm] = useState({ name: '', type: 'cash', currency: 'TWD', initialBalance: '', includeInTotal: true, closingDay: '27', paymentDueDay: '15', autoPaymentAccount: '', holidayAdjustment: 'defer', autoPayment: false });
            const [bookForm, setBookForm] = useState({ name: '', currency: 'TWD', startDate: '', endDate: '' });
            const [recForm, setRecForm] = useState({ name: '', type: 'expense', amount: '', category: '', accountId: '', toAccountId: '', day: new Date().getDate() });

            // --- Initialization Logic ---
            useEffect(() => {
                const initFirebase = () => {
                    if (window.isFirebaseSDKReady && window.FirebaseSDK) {
                        try {
                            // 1. Env Config
                            let config = null;
                            if (typeof window.__firebase_config !== 'undefined' && window.__firebase_config) {
                                config = JSON.parse(window.__firebase_config);
                            } else {
                                // 2. Local Config
                                const localConfig = localStorage.getItem('my_ledger_firebase_config');
                                if (localConfig) {
                                    config = JSON.parse(localConfig);
                                }
                            }

                            if (config) {
                                try {
                                    const app = window.FirebaseSDK.initializeApp(config);
                                    fbRef.current = window.FirebaseSDK;
                                    authRef.current = window.FirebaseSDK.getAuth(app);
                                    dbRef.current = window.FirebaseSDK.getFirestore(app);
                                    setSdkReady(true);
                                } catch(initErr) {
                                    console.error("Firebase Init Failed:", initErr);
                                    setNeedConfig(true); // Re-prompt if init fails
                                    setLoading(false);
                                }
                            } else {
                                setNeedConfig(true);
                                setLoading(false);
                            }
                        } catch (e) {
                            console.error("Firebase Setup Error:", e);
                            setNeedConfig(true);
                            setLoading(false);
                        }
                    } else {
                        setTimeout(initFirebase, 100);
                    }
                };
                initFirebase();
            }, []);

            const handleSaveConfig = () => {
                try {
                    let cleanedInput = configInput.trim();
                    if (cleanedInput.includes("const firebaseConfig") || cleanedInput.includes("var firebaseConfig")) {
                         const firstBrace = cleanedInput.indexOf('{');
                         if (firstBrace !== -1) cleanedInput = cleanedInput.substring(firstBrace);
                    }
                    if (cleanedInput.endsWith(";")) cleanedInput = cleanedInput.slice(0, -1).trim();

                    const config = JSON.parse(cleanedInput);
                    if (!config.apiKey || !config.projectId) throw new Error("è¨­å®šç¼ºå°‘å¿…è¦æ¬„ä½ (apiKey æˆ– projectId)");
                    localStorage.setItem('my_ledger_firebase_config', JSON.stringify(config));
                    window.location.reload();
                } catch (e) {
                    setError({ title: "è¨­å®šç„¡æ•ˆ", message: "è«‹ç¢ºèªæ‚¨è¤‡è£½çš„æ˜¯ JSON æ ¼å¼ã€‚\n\néŒ¯èª¤è¨Šæ¯ï¼š" + e.message });
                }
            };
            
            // Timeout Watchdog
            useEffect(() => {
                const timer = setTimeout(() => {
                    if (loading && !needConfig) {
                        setLoading(false);
                        setError({
                            title: "é€£ç·šé€¾æ™‚ (Connection Timeout)",
                            message: "ç³»çµ±é€£ç·šéä¹…ï¼Œå¯èƒ½æ˜¯å› ç‚ºï¼š\n1. æ‚¨å°šæœªåœ¨ Firebase Console é–‹å•Ÿã€ŒAuthentication > åŒ¿åç™»å…¥ (Anonymous)ã€ã€‚\n2. æ‚¨çš„ç¶²è·¯ç’°å¢ƒé˜»æ“‹äº† Google é€£ç·šã€‚\n3. API Key è¨­å®šæœ‰èª¤ã€‚\n\nè«‹æª¢æŸ¥å¾Œé‡æ–°æ•´ç†é é¢ï¼Œæˆ–é»æ“Šä¸‹æ–¹æŒ‰éˆ•é‡è¨­ã€‚"
                        });
                    }
                }, 15000); 
                return () => clearTimeout(timer);
            }, [loading, needConfig]);

            // Auth Listener (Improved Error Handling)
            useEffect(() => {
                if (!sdkReady) return;
                const auth = authRef.current;
                const unsub = fbRef.current.onAuthStateChanged(auth, async (u) => {
                    if (u) {
                        setUser(u);
                    } else {
                        try {
                            await fbRef.current.signInAnonymously(auth);
                        } catch (e) {
                            console.error("Auth Error:", e);
                            let msg = e.message;
                            if (e.code === 'auth/admin-restricted-operation' || e.code === 'auth/operation-not-allowed') {
                                msg = "åµæ¸¬åˆ°æ‚¨å°šæœªé–‹å•Ÿã€ŒåŒ¿åç™»å…¥ã€åŠŸèƒ½ã€‚\n\nè«‹å‰å¾€ Firebase Console > Authentication > Sign-in methodï¼Œå°‡ã€ŒAnonymousã€è¨­ç‚ºå•Ÿç”¨ã€‚";
                            }
                            setError({ title: "ç™»å…¥å¤±æ•—", message: msg });
                            setLoading(false); 
                        }
                    }
                });
                return () => unsub();
            }, [sdkReady]);
            
            // Google Login Handler with Better Error Message
            const handleGoogleLogin = async () => {
                try {
                    await fbRef.current.signInWithPopup(authRef.current, new fbRef.current.GoogleAuthProvider());
                } catch (e) {
                    let msg = e.message;
                    let title = "ç™»å…¥éŒ¯èª¤";
                    if (e.code === 'auth/unauthorized-domain') {
                        title = "ç¶²åŸŸæœªæˆæ¬Š (Unauthorized Domain)";
                        msg = `Google ç™»å…¥éœ€è¦ç¶²åŸŸæˆæ¬Šã€‚\n\nè«‹å°‡ç›®å‰ç¶²åŸŸï¼š\n${window.location.hostname}\n\nåŠ å…¥åˆ°ï¼š\nFirebase Console > Authentication > Settings > Authorized domains`;
                    } else if (e.code === 'auth/popup-closed-by-user') {
                        msg = "ç™»å…¥è¦–çª—å·²é—œé–‰";
                    }
                    setError({ title, message: msg });
                }
            };

            // --- Data Subscriptions & Logic ---
            useEffect(() => {
                if (!user || !sdkReady) return;
                const userRef = fbRef.current.doc(dbRef.current, 'artifacts', appId, 'users', user.uid);
                
                const runAutoPaymentCheck = async (accountsList) => {
                    const currentMonthStr = getLocalMonth();
                    const creditCards = accountsList.filter(a => a.type === 'credit' && a.autoPayment && a.autoPaymentAccount);
                    if (creditCards.length === 0) return;
                    
                    const batch = fbRef.current.writeBatch(dbRef.current);
                    const txCol = fbRef.current.collection(userRef, 'transactions');
                    let hasUpdates = false;

                    creditCards.forEach(card => {
                        if (card.lastAutoPaymentMonth === currentMonthStr) return;
                        const dueDay = parseInt(card.paymentDueDay || 15);
                        const today = new Date();
                        if (today.getDate() >= dueDay) {
                            const newTxRef = fbRef.current.doc(txCol);
                            batch.set(newTxRef, {
                                type: 'transfer', 
                                amount: 0, 
                                category: 'è‡ªå‹•ç¹³æ¬¾',
                                accountId: card.autoPaymentAccount, 
                                toAccountId: card.id,
                                date: getLocalToday(), 
                                bookId: 'main', 
                                note: `[ç³»çµ±] ä¿¡ç”¨å¡è²»ç¹³æ¬¾ (${card.name})`, 
                                createdAt: new Date().toISOString()
                            });
                            
                            const cardRef = fbRef.current.doc(userRef, 'accounts', card.id);
                            batch.update(cardRef, { lastAutoPaymentMonth: currentMonthStr });
                            hasUpdates = true;
                        }
                    });
                    
                    if (hasUpdates) await batch.commit();
                };

                const unsubs = [
                    fbRef.current.onSnapshot(fbRef.current.collection(userRef, 'transactions'), snap => 
                        setTransactions(snap.docs.map(d => ({id: d.id, ...d.data()})).sort((a,b) => new Date(b.date)-new Date(a.date)))),
                    
                    fbRef.current.onSnapshot(fbRef.current.collection(userRef, 'accounts'), snap => {
                        const accs = snap.docs.map(d => ({id: d.id, ...d.data()}));
                        setAccounts(accs);
                        runAutoPaymentCheck(accs);
                    }),
                    
                    fbRef.current.onSnapshot(fbRef.current.doc(userRef, 'settings', 'config'), doc => {
                        if (doc.exists()) {
                            const data = doc.data().categories;
                            if (data && data.expense && typeof data.expense[0] === 'string') { 
                                const migrate = (arr) => arr.map(name => ({ name, icon: 'tag', subs: [] })); 
                                const newCats = { expense: migrate(data.expense), income: migrate(data.income) };
                                setCategories(newCats);
                                fbRef.current.setDoc(fbRef.current.doc(userRef, 'settings', 'config'), { categories: newCats }, {merge: true});
                            } else if (data) setCategories(data);
                            if (doc.data().budget) setMonthlyBudget(doc.data().budget);
                        } else fbRef.current.setDoc(fbRef.current.doc(userRef, 'settings', 'config'), { categories: DEFAULT_CATEGORIES }, {merge: true});
                    }),

                    fbRef.current.onSnapshot(fbRef.current.doc(userRef, 'settings', 'rates'), doc => {
                        if (doc.exists()) setExchangeRates(doc.data());
                        else fbRef.current.setDoc(fbRef.current.doc(userRef, 'settings', 'rates'), DEFAULT_RATES, {merge: true});
                    }),

                    fbRef.current.onSnapshot(fbRef.current.doc(userRef, 'settings', 'retirement'), doc => {
                        if (doc.exists()) setRetirement(doc.data());
                        else fbRef.current.setDoc(fbRef.current.doc(userRef, 'settings', 'retirement'), retirement, {merge: true});
                    }),

                    fbRef.current.onSnapshot(fbRef.current.collection(userRef, 'recurring'), snap => 
                        setRecurring(snap.docs.map(d => ({id: d.id, ...d.data()})).sort((a,b) => (a.day || 0) - (b.day || 0)))),

                    fbRef.current.onSnapshot(fbRef.current.collection(userRef, 'books'), snap => {
                        const loadedBooks = snap.docs.map(d => ({id: d.id, ...d.data()}));
                        setBooks([{ id: 'main', name: 'æ—¥å¸¸å¸³æœ¬', currency: 'TWD' }, ...loadedBooks]);
                    })
                ];

                setLoading(false);
                return () => unsubs.forEach(unsub => unsub());
            }, [user, sdkReady]);

            // --- Logic & Calculations ---
            const getCategoryIcon = (catName, type) => {
                if (!categories[type]) return 'tag';
                const cat = categories[type].find(c => c.name === catName);
                return cat ? cat.icon : 'tag';
            };

            const isCrossCurrencyTransfer = useMemo(() => {
                if (txForm.type !== 'transfer' || !txForm.accountId || !txForm.toAccountId) return false;
                const source = accounts.find(a => a.id === txForm.accountId);
                const dest = accounts.find(a => a.id === txForm.toAccountId);
                return source && dest && source.currency !== dest.currency;
            }, [txForm.type, txForm.accountId, txForm.toAccountId, accounts]);
            
            const isCreditCardPayment = useMemo(() => {
                if (!txForm.accountId) return false;
                const acc = accounts.find(a => a.id === txForm.accountId);
                return acc && acc.type === 'credit' && txForm.type === 'expense';
            }, [txForm.accountId, txForm.type, accounts]);

            const changeMonth = (offset) => {
                const [year, month] = currentLedgerMonth.split('-').map(Number);
                const newDate = new Date(year, month - 1 + offset, 1);
                const newYear = newDate.getFullYear();
                const newMonth = String(newDate.getMonth() + 1).padStart(2, '0');
                setCurrentLedgerMonth(`${newYear}-${newMonth}`);
            };
            
            const changeAnalysisDate = (offset) => {
                if (analysisMode === 'month') {
                    const [year, month] = analysisDate.split('-').map(Number);
                    const newDate = new Date(year, month - 1 + offset, 1);
                    const newYear = newDate.getFullYear();
                    const newMonth = String(newDate.getMonth() + 1).padStart(2, '0');
                    setAnalysisDate(`${newYear}-${newMonth}`);
                } else if (analysisMode === 'year') {
                    setAnalysisYear(String(parseInt(analysisYear) + offset));
                }
                setSelectedCategory(null);
            };

            const switchBook = (book) => {
                setCurrentBook(book);
                if (book.startDate) {
                    setCurrentLedgerMonth(book.startDate.slice(0, 7));
                    setTxForm(prev => ({ ...prev, date: book.startDate }));
                } else {
                    setCurrentLedgerMonth(getLocalMonth());
                    setTxForm(prev => ({ ...prev, date: getLocalToday() }));
                }
                setIsBookSelectOpen(false);
            };

            const { accountBalances, stats, outstandingDebt, monthlyTransactions, bookStats } = useMemo(() => {
                const bals = {};
                accounts.forEach(acc => bals[acc.id] = parseFloat(acc.initialBalance) || 0);
                
                let totalAsset = 0; 
                let monthIncome = 0; 
                let monthExpense = 0;
                let outstanding = 0;
                let bookTotalExpenseTWD = 0;
                let bookTotalExpenseForeign = 0;

                const targetMonth = currentLedgerMonth; 
                const monthTx = [];
                const currentBookId = currentBook.id;

                transactions.forEach(tx => {
                    const amt = parseFloat(tx.amount) || 0; 
                    if (tx.type === 'income' || tx.type === 'repayment') { if (bals[tx.accountId]!==undefined) bals[tx.accountId] += amt; }
                    else if (tx.type === 'expense' || tx.type === 'advance') { if (bals[tx.accountId]!==undefined) bals[tx.accountId] -= amt; }
                    else if (tx.type === 'transfer') {
                        if (bals[tx.accountId]!==undefined) bals[tx.accountId] -= amt;
                        const inAmt = tx.toAmount ? parseFloat(tx.toAmount) : amt;
                        if (bals[tx.toAccountId]!==undefined) bals[tx.toAccountId] += inAmt;
                    }

                    const txBookId = tx.bookId || 'main';
                    if (txBookId === currentBookId) {
                        const txMonth = tx.date.substring(0, 7);
                        if (txMonth === targetMonth || (currentBook.id !== 'main' && currentBook.startDate && tx.date >= currentBook.startDate && tx.date <= currentBook.endDate)) {
                            monthTx.push(tx); 
                            
                            if (tx.type === 'income') monthIncome += amt;
                            if (tx.type === 'expense') {
                                monthExpense += amt; 
                                if (currentBook.currency !== 'TWD' && tx.currency === currentBook.currency) {
                                    bookTotalExpenseForeign += (tx.foreignAmount || 0);
                                }
                                bookTotalExpenseTWD += amt;
                            }
                        }
                        if (tx.type === 'advance' && !tx.isSettled) outstanding += amt;
                    }
                });

                // Total Asset Calculation (with Market Value Logic)
                accounts.forEach(acc => { 
                    if (acc.includeInTotal) {
                        let val = 0;
                        if (acc.type === 'invest' && acc.marketValue) {
                            val = parseFloat(acc.marketValue);
                        } else {
                            val = bals[acc.id] || 0;
                        }

                        if (acc.currency !== 'TWD') {
                            const rate = exchangeRates[acc.currency] || 1;
                            val = val * rate;
                        }
                        totalAsset += val;
                    }
                });

                return { 
                    accountBalances: bals, 
                    stats: { totalAsset, monthIncome, monthExpense }, 
                    outstandingDebt: outstanding, 
                    monthlyTransactions: monthTx, 
                    bookStats: { twd: bookTotalExpenseTWD, foreign: bookTotalExpenseForeign }
                };
            }, [accounts, transactions, currentLedgerMonth, currentBook, exchangeRates]);

            const retirementStats = useMemo(() => {
                const yearsToRetire = Math.max(0, retirement.retireAge - retirement.currentAge);
                const futureMonthly = retirement.monthlyExpense * Math.pow(1 + (retirement.inflation / 100), yearsToRetire);
                const targetAmount = futureMonthly * 12 * 25;
                const progress = Math.min(100, Math.max(0, (stats.totalAsset / targetAmount) * 100));
                return { targetAmount, progress, yearsToRetire, futureMonthly };
            }, [retirement, stats.totalAsset]);

            const analysisData = useMemo(() => {
                const bookTxs = transactions.filter(tx => (tx.bookId || 'main') === currentBook.id);
                let filteredTx = [];
                if (analysisMode === 'month') {
                    filteredTx = bookTxs.filter(t => t.date.substring(0, 7) === analysisDate);
                }
                else if (analysisMode === 'year') {
                    filteredTx = bookTxs.filter(t => t.date.substring(0, 4) === analysisYear);
                }
                else {
                    filteredTx = bookTxs.filter(t => t.date >= analysisRange.start && t.date <= analysisRange.end);
                }

                const expenseTx = filteredTx.filter(t => t.type === 'expense');
                const totalExpense = expenseTx.reduce((sum, t) => sum + (parseFloat(t.amount)||0), 0);
                const expenseByCategory = {};
                expenseTx.forEach(t => {
                    const key = (analysisGroupBy === 'sub' && t.subCategory) ? t.subCategory : t.category;
                    expenseByCategory[key] = (expenseByCategory[key] || 0) + parseFloat(t.amount);
                });
                const expenseChartData = Object.entries(expenseByCategory)
                    .map(([name, value]) => ({ 
                        name, value, 
                        color: CATEGORY_COLORS[name] || CATEGORY_COLORS[Object.keys(categories.expense.find(c=>c.subs&&c.subs.includes(name))||{})[0]] || '#94a3b8', 
                        percent: totalExpense ? (value / totalExpense) * 100 : 0 
                    }))
                    .sort((a,b) => b.value - a.value);

                const incomeTx = filteredTx.filter(t => t.type === 'income');
                const totalIncome = incomeTx.reduce((sum, t) => sum + (parseFloat(t.amount)||0), 0);
                const incomeByCategory = {};
                incomeTx.forEach(t => {
                    const key = (analysisGroupBy === 'sub' && t.subCategory) ? t.subCategory : t.category;
                    incomeByCategory[key] = (incomeByCategory[key] || 0) + parseFloat(t.amount);
                });
                const incomeChartData = Object.entries(incomeByCategory)
                    .map(([name, value]) => ({ 
                        name, value, 
                        color: CATEGORY_COLORS[name] || '#94a3b8', 
                        percent: totalIncome ? (value / totalIncome) * 100 : 0 
                    }))
                    .sort((a,b) => b.value - a.value);

                return { totalExpense, expenseChartData, totalIncome, incomeChartData, filteredTx };
            }, [transactions, analysisMode, analysisDate, analysisYear, analysisRange, currentBook, analysisGroupBy, categories]);

            const homeInsight = useMemo(() => {
                if (!currentLedgerMonth) return null;
                const [curY, curM] = currentLedgerMonth.split('-').map(Number);
                const prevDate = new Date(curY, curM - 2, 1);
                const prevMonthStr = `${prevDate.getFullYear()}-${String(prevDate.getMonth() + 1).padStart(2, '0')}`;
                
                const calcExpense = (monthStr) => transactions.reduce((sum, tx) => {
                    if (tx.date.startsWith(monthStr) && tx.type === 'expense' && (tx.bookId === 'main' || !tx.bookId)) return sum + (parseFloat(tx.amount) || 0);
                    return sum;
                }, 0);

                const prevMonthExpense = calcExpense(prevMonthStr);
                const currentMonthExpense = calcExpense(currentLedgerMonth);

                if (monthlyBudget > 0 && currentMonthExpense > monthlyBudget) return { type: 'danger', icon: 'alert-triangle', text: `âš ï¸ æœ¬æœˆæ”¯å‡º $${currentMonthExpense.toLocaleString()} å·²è¶…éé ç®— $${monthlyBudget.toLocaleString()}ï¼`, color: 'text-rose-600', bg: 'bg-rose-50 border-rose-200' };
                if (prevMonthExpense > 0 && currentMonthExpense > prevMonthExpense) return { type: 'warning', icon: 'arrow-up-right', text: `ğŸ“ˆ æœ¬æœˆæ”¯å‡ºæ¯”ä¸Šå€‹æœˆå¢åŠ äº† $${(currentMonthExpense - prevMonthExpense).toLocaleString()}ï¼Œè«‹ç•™æ„é–‹éŠ·ã€‚`, color: 'text-amber-600', bg: 'bg-amber-50 border-amber-200' };
                if (prevMonthExpense > 0 && currentMonthExpense < prevMonthExpense) return { type: 'success', icon: 'thumbs-up', text: `ğŸ‰ å¾ˆæ£’ï¼æœ¬æœˆæ”¯å‡ºæ¯”ä¸Šå€‹æœˆå°‘äº† $${(prevMonthExpense - currentMonthExpense).toLocaleString()}ï¼Œç¹¼çºŒä¿æŒï¼`, color: 'text-emerald-600', bg: 'bg-emerald-50 border-emerald-200' };
                return { type: 'neutral', icon: 'info', text: `æœ¬æœˆé ç®— $${monthlyBudget.toLocaleString()}ï¼Œç›®å‰ä½¿ç”¨äº† ${Math.round((currentMonthExpense/monthlyBudget)*100)}%`, color: 'text-slate-600', bg: 'bg-slate-50 border-slate-200' };
            }, [transactions, currentLedgerMonth, monthlyBudget]);

            const retirementInsight = useMemo(() => {
                if (!currentLedgerMonth) return null;
                const savings = stats.monthIncome - stats.monthExpense;
                const target = retirement.monthlyExpense;
                if (savings < 0) return { icon: 'alert-triangle', text: `âš ï¸ æœ¬æœˆç›®å‰é€æ”¯ï¼Œè³‡ç”¢ç¸®æ°´ä¸­ï¼Œé€™æœƒå»¶å¾Œæ‚¨çš„é€€ä¼‘è¨ˆç•«å–”ï¼`, color: 'text-rose-600', bg: 'bg-rose-100' };
                if (savings < target) return { icon: 'target', text: `ğŸ¯ æœ¬æœˆçµé¤˜ $${savings.toLocaleString()}ï¼Œè·é›¢é€€ä¼‘ç›®æ¨™æœˆå­˜é¡é‚„æœ‰å·®è·ï¼ŒåŠ æ²¹ï¼`, color: 'text-amber-600', bg: 'bg-amber-100' };
                return { icon: 'party-popper', text: `ğŸš€ å¤ªæ£’äº†ï¼æœ¬æœˆå„²è“„åŠ›è¶…æ¨™ï¼Œæ­£åŠ é€Ÿé‚å‘è²¡å‹™è‡ªç”±ï¼`, color: 'text-emerald-600', bg: 'bg-emerald-100' };
            }, [stats, retirement, currentLedgerMonth]);

            // --- Handlers (Submit, Settle, etc.) ---
            const handleTxSubmit = async (e) => { e.preventDefault(); const twdAmount = parseFloat(txForm.amount); const foreignAmount = parseFloat(txForm.foreignAmount) || 0; if (!twdAmount || !txForm.accountId) return; const batch = fbRef.current.writeBatch(dbRef.current); const userRef = fbRef.current.doc(dbRef.current, 'artifacts', appId, 'users', user.uid); const txCol = fbRef.current.collection(userRef, 'transactions'); const bookId = currentBook.id; const baseTxData = { accountId: txForm.accountId, date: txForm.date, note: txForm.note, bookId: bookId, createdAt: new Date().toISOString(), currency: txForm.currency, foreignAmount: foreignAmount > 0 ? foreignAmount : null, exchangeRate: foreignAmount > 0 ? (twdAmount / foreignAmount) : 1 }; if (txForm.type === 'expense' && installment.enabled && isCreditCardPayment) { const periods = parseInt(installment.periods)||3; const amountPerMonth = Math.round(twdAmount/periods); const remainder = twdAmount - (amountPerMonth*periods); for(let i=0;i<periods;i++){ const currentMonthAmount = i===0 ? amountPerMonth+remainder : amountPerMonth; let installmentDate; if(i===0){ installmentDate=txForm.date; }else{ const [y,m,d]=txForm.date.split('-').map(Number); const nextDate=new Date(y,m-1+i,1); installmentDate=`${nextDate.getFullYear()}-${String(nextDate.getMonth()+1).padStart(2,'0')}-01`; } let finalCategory=txForm.category; if(!finalCategory){ if(categories[txForm.type] && categories[txForm.type].length>0) finalCategory=categories[txForm.type][0].name; else finalCategory='æœªåˆ†é¡'; } batch.set(fbRef.current.doc(txCol), { ...baseTxData, date: installmentDate, amount: currentMonthAmount, type: 'expense', category: finalCategory, subCategory: txForm.subCategory, note: `${txForm.note||''} (åˆ†æœŸ ${i+1}/${periods})` }); } } else if (txForm.type === 'expense' && isAdvanceSplit) { let totalAdvanceTWD = 0; const validAdvances = splitData.advances.filter(a => a.debtor && a.amount); validAdvances.forEach(a => totalAdvanceTWD += parseFloat(a.amount)); if (totalAdvanceTWD > twdAmount) return; const myExpense = twdAmount - totalAdvanceTWD; if (myExpense > 0) { batch.set(fbRef.current.doc(txCol), { ...baseTxData, type: 'expense', amount: myExpense, category: txForm.category || categories.expense[0].name, subCategory: txForm.subCategory }); } validAdvances.forEach(adv => { batch.set(fbRef.current.doc(txCol), { ...baseTxData, type: 'advance', amount: parseFloat(adv.amount), category: 'ä»£å¢Š', note: `ä»£è²·: ${txForm.note || 'å•†å“'}`, debtor: adv.debtor, isSettled: false, foreignAmount: null }); }); } else if (txForm.type === 'income' && isAdvanceSplit) { const principal = parseFloat(splitData.principalAmount) || 0; const gain = twdAmount - principal; if (principal > 0) { batch.set(fbRef.current.doc(txCol), { ...baseTxData, type: 'transfer', amount: principal, category: 'è½‰å¸³', accountId: splitData.sourceAccountId, toAccountId: txForm.accountId, note: `æŠ•è³‡æœ¬é‡‘æ”¶å›` }); } if (gain !== 0) { batch.set(fbRef.current.doc(txCol), { ...baseTxData, type: 'income', amount: gain, category: txForm.category || 'æŠ•è³‡', note: `æŠ•è³‡ç²åˆ©` }); } } else { let finalCategory = txForm.category; if (!finalCategory) { if (txForm.type === 'transfer') finalCategory = 'è½‰å¸³'; else if (categories[txForm.type] && categories[txForm.type].length > 0) finalCategory = categories[txForm.type][0].name; else finalCategory = 'æœªåˆ†é¡'; } const txData = { ...baseTxData, type: txForm.type, category: finalCategory, subCategory: txForm.subCategory, amount: twdAmount }; if (isCrossCurrencyTransfer) { txData.toAmount = parseFloat(txForm.toAmount); } batch.set(fbRef.current.doc(txCol), txData); } await batch.commit(); setIsTxModalOpen(false); resetTxForm(); };
            const resetTxForm = () => { setTxForm({ type: 'expense', amount: '', foreignAmount: '', toAmount: '', category: '', subCategory: '', accountId: '', toAccountId: '', debtor: '', date: (currentBook.startDate && currentBook.id !== 'main') ? currentBook.startDate : getLocalToday(), note: '', currency: currentBook.currency }); setIsAdvanceSplit(false); setInstallment({ enabled: false, periods: 3 }); setSplitData({ advances: [{ debtor: '', amount: '' }], principalAmount: '', sourceAccountId: '' }); };
            const handleBookSubmit = async (e) => { e.preventDefault(); if(!bookForm.name) return; await fbRef.current.addDoc(fbRef.current.collection(dbRef.current, 'artifacts', appId, 'users', user.uid, 'books'), { ...bookForm, createdAt: new Date().toISOString() }); setIsBookModalOpen(false); setBookForm({ name: '', currency: 'TWD', startDate: '', endDate: '' }); };
            const handleSettle = async (e) => { e.preventDefault(); if (!settleTargetTx || !settleToAccount) return; const batch = fbRef.current.writeBatch(dbRef.current); const userRef = fbRef.current.doc(dbRef.current, 'artifacts', appId, 'users', user.uid); batch.update(fbRef.current.doc(userRef, 'transactions', settleTargetTx.id), { isSettled: true, settledDate: new Date().toISOString().split('T')[0] }); batch.set(fbRef.current.doc(fbRef.current.collection(userRef, 'transactions')), { type: 'repayment', amount: parseFloat(settleTargetTx.amount), category: 'é‚„æ¬¾', accountId: settleToAccount, date: new Date().toISOString().split('T')[0], note: `æ”¶å›: ${settleTargetTx.debtor}`, relatedTxId: settleTargetTx.id, bookId: 'main', createdAt: new Date().toISOString() }); await batch.commit(); setIsSettleModalOpen(false); setSettleTargetTx(null); setSettleToAccount(''); };
            const handleAccSubmit = async (e) => { e.preventDefault(); if (!accForm.name) return; await fbRef.current.addDoc(fbRef.current.collection(dbRef.current, 'artifacts', appId, 'users', user.uid, 'accounts'), { ...accForm, createdAt: new Date().toISOString() }); setIsAccModalOpen(false); setAccForm({ name: '', type: 'cash', currency: 'TWD', initialBalance: '', includeInTotal: true, closingDay: '27', paymentDueDay: '15', autoPaymentAccount: '', holidayAdjustment: 'defer', autoPayment: false }); };
            const handleRecSubmit = async (e) => { e.preventDefault(); if (!recForm.name) return; await fbRef.current.addDoc(fbRef.current.collection(dbRef.current, 'artifacts', appId, 'users', user.uid, 'recurring'), { ...recForm, amount: parseFloat(recForm.amount), day: parseInt(recForm.day), createdAt: new Date().toISOString() }); setIsRecModalOpen(false); };
            const handleRetireSubmit = async (e) => { e.preventDefault(); await fbRef.current.setDoc(fbRef.current.doc(dbRef.current, 'artifacts', appId, 'users', user.uid, 'settings', 'retirement'), { ...retireForm, currentAge: parseInt(retireForm.currentAge), retireAge: parseInt(retireForm.retireAge), monthlyExpense: parseFloat(retireForm.monthlyExpense), inflation: parseFloat(retireForm.inflation) }); setIsRetireModalOpen(false); };
            const handleBudgetSubmit = async (newBudget) => { await fbRef.current.updateDoc(fbRef.current.doc(dbRef.current, 'artifacts', appId, 'users', user.uid, 'settings', 'config'), { budget: parseFloat(newBudget) }); setMonthlyBudget(parseFloat(newBudget)); };
            const handleAddCategory = async () => { if (!newCatForm.name.trim()) return; const type = newCatForm.type || editingCategoryType; const newCats = { ...categories, [type]: [...categories[type], { name: newCatForm.name.trim(), icon: newCatForm.icon, subs: [] }] }; await fbRef.current.updateDoc(fbRef.current.doc(dbRef.current, 'artifacts', appId, 'users', user.uid, 'settings', 'config'), { categories: newCats }); setIsAddCatModalOpen(false); setNewCatForm({name:'', icon:'tag', type: 'expense', subs: []}); };
            const handleDeleteCategory = async (catName) => { const newCats = { ...categories, [editingCategoryType]: categories[editingCategoryType].filter(c => c.name !== catName) }; await fbRef.current.updateDoc(fbRef.current.doc(dbRef.current, 'artifacts', appId, 'users', user.uid, 'settings', 'config'), { categories: newCats }); };
            const handleRatesSubmit = async (e) => { e.preventDefault(); await fbRef.current.setDoc(fbRef.current.doc(dbRef.current, 'artifacts', appId, 'users', user.uid, 'settings', 'rates'), exchangeRates, {merge: true}); setIsRateModalOpen(false); };
            const handleAddSubCategory = async (mainCatName, subName) => { if (!subName.trim()) return; const newCats = { ...categories }; const catIndex = newCats[editingCategoryType].findIndex(c => c.name === mainCatName); if (catIndex > -1) { if (!newCats[editingCategoryType][catIndex].subs) newCats[editingCategoryType][catIndex].subs = []; if (!newCats[editingCategoryType][catIndex].subs.includes(subName.trim())) { newCats[editingCategoryType][catIndex].subs.push(subName.trim()); await fbRef.current.updateDoc(fbRef.current.doc(dbRef.current, 'artifacts', appId, 'users', user.uid, 'settings', 'config'), { categories: newCats }); } } };
            const handleDeleteSubCategory = async (mainCatName, subName) => { const newCats = { ...categories }; const catIndex = newCats[editingCategoryType].findIndex(c => c.name === mainCatName); if (catIndex > -1) { newCats[editingCategoryType][catIndex].subs = newCats[editingCategoryType][catIndex].subs.filter(s => s !== subName); await fbRef.current.updateDoc(fbRef.current.doc(dbRef.current, 'artifacts', appId, 'users', user.uid, 'settings', 'config'), { categories: newCats }); } };
            const deleteItem = async (col, id) => { await fbRef.current.deleteDoc(fbRef.current.doc(dbRef.current, 'artifacts', appId, 'users', user.uid, col, id)); };
            const applyRecurring = (rec) => { const today = new Date(); const targetDay = Math.min(parseInt(rec.day||today.getDate()), new Date(today.getFullYear(), today.getMonth()+1, 0).getDate()); setTxForm({ type: rec.type, amount: rec.amount, category: rec.category||categories[rec.type][0].name, accountId: rec.accountId||'', toAccountId: rec.toAccountId||'', date: `${today.getFullYear()}-${String(today.getMonth()+1).padStart(2,'0')}-${String(targetDay).padStart(2,'0')}`, note: rec.name, currency: 'TWD' }); setActiveTab('home'); setIsTxModalOpen(true); };
            
            const updateAdvanceRow = (index, field, value) => { const newAdvances = [...splitData.advances]; newAdvances[index][field] = value; setSplitData({...splitData, advances: newAdvances}); };
            const addAdvanceRow = () => { setSplitData({...splitData, advances: [...splitData.advances, { debtor: '', amount: '' }]}); };
            const removeAdvanceRow = (index) => { const newAdvances = splitData.advances.filter((_, i) => i !== index); setSplitData({...splitData, advances: newAdvances}); };
            const handleUpdateMarketValue = async (e) => { e.preventDefault(); if (!targetMarketAccount) return; const accRef = fbRef.current.doc(dbRef.current, 'artifacts', appId, 'users', user.uid, 'accounts', targetMarketAccount.id); await fbRef.current.updateDoc(accRef, { marketValue: parseFloat(newMarketValue) || 0 }); setIsMarketValueModalOpen(false); setNewMarketValue(''); };
            const openMarketValueModal = (acc) => { setTargetMarketAccount(acc); setNewMarketValue(acc.marketValue || ''); setIsMarketValueModalOpen(true); };

            if (needConfig) {
                return (
                    <div className="min-h-screen bg-slate-50 flex items-center justify-center p-6">
                        <div className="bg-white max-w-md w-full p-8 rounded-3xl shadow-xl border border-slate-100">
                            <div className="flex justify-center mb-6 text-slate-800"><Icon name="settings" size={48} /></div>
                            <h2 className="text-2xl font-bold text-center text-slate-800 mb-2">åˆæ¬¡è¨­å®š</h2>
                            <p className="text-sm text-slate-500 text-center mb-6">é€™æ˜¯æ‚¨å°ˆå±¬çš„é›¢ç·šç‰ˆæœ¬ã€‚ç‚ºäº†å°‡è³‡æ–™å­˜å„²åœ¨æ‚¨çš„ç§äººé›²ç«¯ï¼Œè«‹è¼¸å…¥ Firebase è¨­å®šæª”ã€‚</p>
                            <textarea className="w-full h-48 p-4 bg-slate-50 rounded-xl border border-slate-200 text-xs font-mono mb-4 focus:ring-2 focus:ring-slate-400 outline-none resize-none" placeholder={'{\n  "apiKey": "...",\n  "authDomain": "...",\n  "projectId": "..."\n}'} value={configInput} onChange={e => setConfigInput(e.target.value)} />
                            <button onClick={handleSaveConfig} className="w-full bg-slate-800 text-white py-4 rounded-xl font-bold text-lg hover:bg-slate-700 transition-colors shadow-lg">å„²å­˜ä¸¦é–‹å§‹ä½¿ç”¨</button>
                            <div className="mt-6 text-center"><a href="https://firebase.google.com/" target="_blank" className="text-xs text-blue-500 hover:underline">å‰å¾€ Firebase Console å–å¾—è¨­å®š</a></div>
                            
                            {error && (
                                <div className="fixed inset-0 z-[60] bg-slate-900/50 flex items-center justify-center p-4">
                                    <div className="bg-white p-8 rounded-3xl shadow-xl border border-slate-100 max-w-xs">
                                        <h3 className="font-bold text-xl text-red-500 mb-2">{error.title}</h3>
                                        <p className="text-stone-600 mb-6 whitespace-pre-wrap">{error.message}</p>
                                        <button onClick={()=>setError(null)} className="w-full bg-slate-800 text-white py-3 rounded-xl font-bold hover:bg-slate-700">æˆ‘çŸ¥é“äº†</button>
                                        <button onClick={()=>{localStorage.removeItem('my_ledger_firebase_config');window.location.reload();}} className="w-full bg-stone-100 text-stone-500 py-3 rounded-xl font-bold mt-2 hover:bg-stone-200">é‡è¨­ Firebase è¨­å®š</button>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            if (!sdkReady || loading) return <div className="h-screen flex items-center justify-center bg-gray-50"><Icon name="loader-2" className="animate-spin text-slate-500" size={40}/></div>;

            const chartData = analysisType === 'expense' ? analysisData.expenseChartData : analysisData.incomeChartData;
            const totalAmount = analysisType === 'expense' ? analysisData.totalExpense : analysisData.totalIncome;

            return (
                <div className="min-h-screen pb-24 max-w-xl mx-auto bg-slate-50 relative">
                    {/* Header */}
                    <header className="sticky top-0 z-20 bg-white border-b border-gray-100 px-6 py-4 flex justify-between items-center shadow-sm">
                        <div className="flex items-center gap-3 cursor-pointer p-2 hover:bg-gray-50 rounded-xl transition-all" onClick={() => setIsBookSelectOpen(true)}>
                            <div className="bg-slate-600 p-2.5 rounded-xl text-white shadow-md shadow-slate-200"><Icon name={currentBook.id==='main'?'book':'plane'} size={22}/></div>
                            <div>
                                <h1 className="font-bold text-lg text-slate-700 tracking-wide flex items-center gap-1.5">{currentBook.name} <Icon name="chevron-down" size={16} className="text-slate-400 stroke-[3]"/></h1>
                                <p className="text-xs text-slate-500 font-medium">{currentBook.currency === 'TWD' ? 'æ—¥å¸¸å¸³æœ¬' : 'æ—…éŠæ¨¡å¼'}</p>
                            </div>
                        </div>
                        {user?.isAnonymous ? <button onClick={handleGoogleLogin} className="text-sm font-bold text-slate-600 bg-slate-100 px-4 py-2 rounded-lg hover:bg-slate-200 transition-colors">ç™»å…¥ç¶å®š</button> : <div className="h-10 w-10 rounded-full overflow-hidden border-2 border-gray-200 shadow-sm"><img src={user.photoURL} alt="User"/></div>}
                    </header>

                    {/* Book Selector Overlay */}
                    {isBookSelectOpen && (
                        <div className="fixed inset-0 z-[70] bg-slate-900/60 backdrop-blur-sm flex flex-col justify-end sm:justify-center p-4" onClick={()=>setIsBookSelectOpen(false)}>
                            <div className="bg-white w-full max-w-sm mx-auto rounded-xl p-6 shadow-2xl animate-in slide-in-from-bottom" onClick={e=>e.stopPropagation()}>
                                <div className="flex justify-between items-center mb-4">
                                    <h3 className="font-bold text-xl text-slate-900">åˆ‡æ›å¸³æœ¬</h3>
                                    <button onClick={()=>setIsBookSelectOpen(false)}><Icon name="x" size={24} className="text-gray-400 hover:text-gray-600"/></button>
                                </div>
                                <div className="space-y-2 max-h-80 overflow-y-auto mb-4">
                                    {books.map(book => (
                                        <button key={book.id} onClick={() => switchBook(book)} 
                                            className={`w-full p-4 rounded-xl flex items-center justify-between transition-all ${currentBook.id === book.id ? 'bg-blue-50 border border-blue-200' : 'bg-white border border-gray-100 hover:bg-gray-50'}`}>
                                            <div className="flex items-center gap-3">
                                                <div className={`p-2 rounded-lg ${book.id==='main'?'bg-slate-100 text-slate-600':'bg-blue-100 text-blue-600'}`}>
                                                    <Icon name={book.id==='main'?'book':'plane'} size={20}/>
                                                </div>
                                                <div className="text-left">
                                                    <p className={`font-bold ${currentBook.id === book.id ? 'text-blue-700' : 'text-slate-700'}`}>{book.name}</p>
                                                    {book.startDate && <p className="text-xs text-gray-400">{book.startDate} ~ {book.endDate}</p>}
                                                </div>
                                            </div>
                                            {currentBook.id === book.id && <Icon name="check" size={20} className="text-blue-600"/>}
                                        </button>
                                    ))}
                                </div>
                                <button onClick={()=>{setIsBookSelectOpen(false); setIsBookModalOpen(true)}} className="w-full bg-slate-600 text-white py-4 rounded-xl font-bold flex justify-center items-center gap-2 hover:bg-slate-700"><Icon name="plus" size={18}/> æ–°å¢æ—…éŠå¸³æœ¬</button>
                            </div>
                        </div>
                    )}
                    
                    {/* Book Creation Modal (RESTORED) */}
                    {isBookModalOpen && (
                        <div className="fixed inset-0 z-[80] bg-slate-900/60 backdrop-blur-sm flex flex-col justify-end sm:justify-center p-4">
                             <div className="bg-white w-full max-w-sm mx-auto rounded-xl p-6 shadow-2xl animate-in slide-in-from-bottom">
                                <h3 className="font-bold text-xl mb-6 text-slate-800">æ–°å¢æ—…éŠå¸³æœ¬</h3>
                                <form onSubmit={handleBookSubmit} className="space-y-4">
                                    <input type="text" placeholder="å¸³æœ¬åç¨± (ä¾‹å¦‚: æ±äº¬ä¹‹æ—…)" className="w-full bg-gray-50 p-4 rounded-xl font-bold outline-none border border-gray-200" value={bookForm.name} onChange={e=>setBookForm({...bookForm, name:e.target.value})}/>
                                    <div>
                                        <p className="text-xs font-bold text-gray-400 mb-1">ä¸»è¦å¹£åˆ¥</p>
                                        <select className="w-full bg-gray-50 p-3 rounded-xl font-bold outline-none border border-gray-200" value={bookForm.currency} onChange={e=>setBookForm({...bookForm, currency:e.target.value})}>
                                            {CURRENCIES.map(c => <option key={c} value={c}>{c}</option>)}
                                        </select>
                                    </div>
                                    <div className="grid grid-cols-2 gap-2">
                                        <div><p className="text-xs font-bold text-gray-400 mb-1">é–‹å§‹æ—¥æœŸ</p><input type="date" className="w-full bg-gray-50 p-3 rounded-xl font-bold outline-none text-sm border border-gray-200" value={bookForm.startDate} onChange={e=>setBookForm({...bookForm, startDate:e.target.value})}/></div>
                                        <div><p className="text-xs font-bold text-gray-400 mb-1">çµæŸæ—¥æœŸ</p><input type="date" className="w-full bg-gray-50 p-3 rounded-xl font-bold outline-none text-sm border border-gray-200" value={bookForm.endDate} onChange={e=>setBookForm({...bookForm, endDate:e.target.value})}/></div>
                                    </div>
                                    <button type="submit" className="w-full bg-slate-600 text-white py-4 rounded-xl font-bold shadow-lg hover:bg-slate-700">å»ºç«‹å¸³æœ¬</button>
                                    <button type="button" onClick={()=>setIsBookModalOpen(false)} className="w-full py-3 text-gray-400 font-bold hover:text-gray-600">å–æ¶ˆ</button>
                                </form>
                             </div>
                        </div>
                    )}

                    {/* Simplified Settle Modal */}
                    {isSettleModalOpen && <div className="fixed inset-0 z-50 bg-stone-900/40 backdrop-blur-sm flex items-end sm:items-center justify-center p-0 sm:p-4"><div className="bg-white w-full max-w-md rounded-t-[2rem] sm:rounded-[2rem] p-8 animate-in slide-in-from-bottom"><h3 className="font-bold text-2xl mb-2 text-stone-800">æ”¶å›ä»£å¢Šæ¬¾</h3><p className="text-stone-500 mb-6">å¾ <span className="font-bold text-stone-800">{settleTargetTx?.debtor}</span> æ”¶å› ${settleTargetTx?.amount}</p><form onSubmit={handleSettle} className="space-y-6"><div><p className="text-xs font-bold text-stone-400 uppercase ml-2 mb-2">å­˜å…¥å¸³æˆ¶</p><select required className="w-full bg-stone-50 p-4 rounded-xl text-base font-bold outline-none text-stone-700 border border-gray-200" value={settleToAccount} onChange={e=>setSettleToAccount(e.target.value)}><option value="" disabled>é¸æ“‡å¸³æˆ¶</option>{accounts.map(a=><option key={a.id} value={a.id}>{a.name}</option>)}</select></div><button type="submit" className="w-full bg-emerald-600 text-white py-5 rounded-xl font-bold text-xl shadow-lg shadow-emerald-200 hover:bg-emerald-700">ç¢ºèªæ”¶æ¬¾</button><button type="button" onClick={()=>{setIsSettleModalOpen(false);setSettleTargetTx(null)}} className="w-full bg-slate-100 text-slate-500 py-4 rounded-xl font-bold hover:bg-slate-200">å–æ¶ˆ</button></form></div></div>}
                    {/* Simplified Rec Modal */}
                    {isRecModalOpen && <div className="fixed inset-0 z-50 bg-stone-900/40 backdrop-blur-sm flex items-end sm:items-center justify-center p-0 sm:p-4"><div className="bg-white w-full max-w-md rounded-t-[2rem] sm:rounded-[2rem] p-8 animate-in slide-in-from-bottom"><div className="flex justify-between mb-8"><h3 className="font-bold text-2xl text-stone-800">æ–°å¢å›ºå®šé …ç›®</h3><button onClick={()=>setIsRecModalOpen(false)} className="bg-stone-100 p-2 rounded-full text-stone-500 hover:bg-stone-200"><Icon name="x" size={24}/></button></div><form onSubmit={handleRecSubmit} className="space-y-6"><div className="bg-stone-100 p-1 rounded-xl flex"> {[{id:'expense',l:'æ”¯å‡º'},{id:'income',l:'æ”¶å…¥'},{id:'transfer',l:'è½‰å¸³'}].map(t => (<button key={t.id} type="button" onClick={()=>setRecForm({...recForm, type:t.id, category: t.id==='transfer'?'è½‰å¸³':categories[t.id][0].name})} className={`flex-1 py-3 rounded-lg text-base font-bold transition-all ${recForm.type===t.id?'bg-white shadow text-slate-600':'text-slate-500'}`}>{t.l}</button>))} </div><div className="flex gap-4"><input type="text" required placeholder="é …ç›®åç¨± (å¦‚: æˆ¿ç§Ÿ)" className="flex-1 bg-stone-50 p-4 rounded-xl font-bold outline-none text-base border border-gray-200" value={recForm.name} onChange={e=>setRecForm({...recForm, name:e.target.value})}/><div className="w-32 bg-stone-50 rounded-xl p-2 border border-gray-200"><p className="text-xs font-bold text-slate-400 uppercase mb-1 ml-1">æ¯æœˆå¹¾è™Ÿ</p><select className="w-full bg-transparent font-bold outline-none text-base text-stone-700" value={recForm.day} onChange={e=>setRecForm({...recForm, day:e.target.value})}>{[...Array(31)].map((_, i) => <option key={i+1} value={i+1}>{i+1} è™Ÿ</option>)}</select></div></div><input type="number" required placeholder="é‡‘é¡" className="w-full bg-stone-50 p-4 rounded-xl font-bold outline-none text-xl border border-gray-200 tabular-nums" value={recForm.amount} onChange={e=>setRecForm({...recForm, amount:e.target.value})}/>{recForm.type !== 'transfer' ? (<><div><p className="text-xs font-bold text-stone-400 uppercase ml-2 mb-2">é¡åˆ¥</p><div className="flex flex-wrap gap-3 max-h-40 overflow-y-auto">{categories[recForm.type] && categories[recForm.type].map(c => <button key={c.name} type="button" onClick={()=>setRecForm({...recForm, category:c.name})} className={`px-4 py-2 rounded-lg text-sm font-bold border ${recForm.category===c.name?'bg-blue-600 text-white border-blue-600':'bg-white border-stone-200 text-stone-500'}`}>{c.name}</button>)}</div></div><div><p className="text-xs font-bold text-stone-400 uppercase ml-2 mb-2">é è¨­æ‰£æ¬¾å¸³æˆ¶ (é¸å¡«)</p><select className="w-full bg-stone-50 p-4 rounded-xl text-base font-bold outline-none text-stone-700 border border-gray-200" value={recForm.accountId} onChange={e=>setRecForm({...recForm, accountId:e.target.value})}><option value="">ä¸æŒ‡å®š (æ¯æ¬¡è©¢å•)</option>{accounts.map(a=><option key={a.id} value={a.id}>{a.name}</option>)}</select></div></>) : (<div className="grid grid-cols-2 gap-4"><div><p className="text-xs font-bold text-stone-400 uppercase ml-2 mb-2">è½‰å‡ºå¸³æˆ¶</p><select required className="w-full bg-stone-50 p-4 rounded-xl text-base font-bold outline-none" value={recForm.accountId} onChange={e=>setRecForm({...recForm, accountId:e.target.value})}><option value="" disabled>é¸æ“‡å¸³æˆ¶</option>{accounts.map(a=><option key={a.id} value={a.id}>{a.name}</option>)}</select></div><div><p className="text-xs font-bold text-stone-400 uppercase ml-2 mb-2">è½‰å…¥å¸³æˆ¶</p><select required className="w-full bg-stone-50 p-4 rounded-xl text-base font-bold outline-none" value={recForm.toAccountId} onChange={e=>setRecForm({...recForm, toAccountId:e.target.value})}><option value="" disabled>é¸æ“‡å¸³æˆ¶</option>{accounts.filter(a=>a.id!==recForm.accountId).map(a=><option key={a.id} value={a.id}>{a.name}</option>)}</select></div></div>)}<button type="submit" className="w-full bg-slate-600 text-white py-5 rounded-xl font-bold text-xl shadow-lg hover:bg-slate-700">æ–°å¢å›ºå®šé …ç›®</button></form></div></div>}
                    {/* Simplified Acc Modal */}
                    {isAccModalOpen && <div className="fixed inset-0 z-50 bg-stone-900/40 backdrop-blur-sm flex items-end sm:items-center justify-center p-0 sm:p-4"><div className="bg-white w-full max-w-md rounded-t-[2rem] sm:rounded-[2rem] p-8 animate-in slide-in-from-bottom"><div className="flex justify-between mb-8"><h3 className="font-bold text-2xl text-stone-800">æ–°å¢å¸³æˆ¶</h3><button onClick={()=>setIsAccModalOpen(false)} className="bg-stone-100 p-2 rounded-full text-stone-500"><Icon name="x" size={24}/></button></div><form onSubmit={handleAccSubmit} className="space-y-6"><input type="text" required placeholder="å¸³æˆ¶åç¨± (ä¾‹å¦‚: ç‰å±±éŠ€è¡Œ)" className="w-full bg-stone-50 p-4 rounded-xl font-bold text-base border border-gray-200" value={accForm.name} onChange={e=>setAccForm({...accForm, name:e.target.value})}/><div className="space-y-2"><p className="text-xs font-bold text-stone-400 ml-1">é¡å‹</p><select className="w-full bg-stone-50 p-4 rounded-xl font-bold text-base border border-gray-200" value={accForm.type} onChange={e=>setAccForm({...accForm, type:e.target.value})}>{Object.entries(ACCOUNT_TYPES).map(([k, v]) => <option key={k} value={k}>{v.label}</option>)}</select></div><div className="flex gap-4"><div className="flex-1"><p className="text-xs font-bold text-stone-400 mb-2 ml-1">åˆå§‹é¤˜é¡</p><input type="number" required placeholder="0" className="w-full bg-stone-50 p-4 rounded-xl font-bold text-base border border-gray-200 tabular-nums" value={accForm.initialBalance} onChange={e=>setAccForm({...accForm, initialBalance:e.target.value})}/></div><div className="w-28"><p className="text-xs font-bold text-stone-400 mb-2 ml-1">å¹£åˆ¥</p><select className="w-full bg-stone-50 p-4 rounded-xl font-bold text-base border border-gray-200" value={accForm.currency} onChange={e=>setAccForm({...accForm, currency:e.target.value})}><option value="TWD">TWD</option><option value="USD">USD</option><option value="JPY">JPY</option></select></div></div><button type="submit" className="w-full bg-blue-600 text-white py-5 rounded-xl font-bold text-xl shadow-lg hover:bg-blue-700">å»ºç«‹å¸³æˆ¶</button></form></div></div>}
                    {/* Simplified Retire Modal */}
                    {isRetireModalOpen && <div className="fixed inset-0 z-50 bg-stone-900/40 backdrop-blur-sm flex items-end sm:items-center justify-center p-0 sm:p-4"><div className="bg-white w-full max-w-md rounded-t-[2rem] sm:rounded-[2rem] p-8 animate-in slide-in-from-bottom"><h3 className="font-bold text-2xl mb-8 text-slate-800">é€€ä¼‘è¨­å®š</h3><form onSubmit={handleRetireSubmit} className="space-y-6"><input type="number" required placeholder="ç›®å‰å¹´é½¡" className="w-full bg-stone-50 p-4 rounded-xl font-bold border border-gray-200 tabular-nums" value={retireForm.currentAge} onChange={e=>setRetireForm({...retireForm, currentAge:e.target.value})}/><input type="number" required placeholder="é€€ä¼‘å¹´é½¡" className="w-full bg-stone-50 p-4 rounded-xl font-bold border border-gray-200 tabular-nums" value={retireForm.retireAge} onChange={e=>setRetireForm({...retireForm, retireAge:e.target.value})}/><input type="number" required placeholder="æœˆèŠ±è²»" className="w-full bg-stone-50 p-4 rounded-xl font-bold border border-gray-200 tabular-nums" value={retireForm.monthlyExpense} onChange={e=>setRetireForm({...retireForm, monthlyExpense:e.target.value})}/><input type="number" required placeholder="é€šè†¨ç‡" className="w-full bg-stone-50 p-4 rounded-xl font-bold border border-gray-200 tabular-nums" value={retireForm.inflation} onChange={e=>setRetireForm({...retireForm, inflation:e.target.value})}/><button type="submit" className="w-full bg-amber-500 text-white py-5 rounded-xl font-bold text-xl shadow-lg">å„²å­˜</button></form></div></div>}
                    
                    {error && <div className="fixed inset-0 z-[60] bg-stone-900/50 flex items-center justify-center p-4"><div className="bg-white p-8 rounded-3xl shadow-xl border border-slate-100"><h3 className="font-bold text-xl text-rose-500 mb-2">{error.title}</h3><p className="text-stone-600 mb-6 whitespace-pre-wrap">{error.message}</p><button onClick={()=>setError(null)} className="w-full bg-stone-800 text-white py-3 rounded-xl font-bold hover:bg-stone-700">æˆ‘çŸ¥é“äº†</button><button onClick={()=>{localStorage.removeItem('my_ledger_firebase_config');window.location.reload();}} className="w-full bg-stone-100 text-stone-500 py-3 rounded-xl font-bold mt-2 hover:bg-stone-200">é‡è¨­ Firebase è¨­å®š</button></div></div>}
                </div>
            );
        }

        function NavBtn({icon, label, active, onClick}) {
            return <button onClick={onClick} className={`flex flex-col items-center gap-1 ${active?'text-slate-600 scale-105':'text-slate-400 hover:text-slate-600'}`}>{icon}<span className="text-xs font-bold">{label}</span></button>;
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>